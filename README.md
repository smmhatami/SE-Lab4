# گزارش آزمایش چهارم درس مهندسی نرم افزار

## اعضای گروه

+ سید محمدمهدی حاتمی 98109561
+ پیمان حاجی محمد 98170776

## شرح آزمایش

### گام صفر : ساخت پروژه 

در ابتدای امر همچون آزمایش های قبلی محیط گیت را راه اندازی کرده و قوانین لازم روی برنچ اصلی آن را اعمال می کنیم. 

سپس ساختار و فولدر بندی پروژه را تشکیل میدهیم و با کمک افزونه ی مناسب، محیط تست را راه اندازی می کنیم. 


### گام یک : طراحی ساختار پروژه

حال با توجه به توصیفات ارائه شده، ساختار مناسب پروژه را طراحی می کنیم. در تصویر زیر نمودار UML طراحی شده را مشاهده می کنید. در این نمودار تمام متد های کلاس ها را ننوشته ایم و تنها به متد های اصلی مرتبط با الگوهای طراحی مان بسنده کرده ایم. 

![selab4](https://github.com/smmhatami/SE-Lab4/assets/62210297/b877ac0d-b8a3-4d74-9c26-65da9b375ab4)

همینطور که مشاهده می کنید برای نگهداری وضعیت بسته ها از الگوی طراحی State و برای نگهداری روش ارسال از الگوی طراحی Stragegy استفاده کرده ایم. 

الگوی State : دلیل این انتخاب این است که وضعیت یک بسته قابل مدل سازی با یک ماشین اتوماتا است و الگوی State برای این نیازمندی طراحی شده است. ساختار کلی این الگو به این صورت است که یک Context به عنوان موجودیتی که چند وضعیت دارد تعریف می شود که یک ویژگی state روی خودش دارد که توسط یک واسط بیان می شود. حال وضعیت های مختلف این موجودیت در قالب پیاده سازی های مختلف این واسط بیان می شوند. در طراحی ما Pack کانتکست است و PackState وضعیت آن است. در تصویر زیر ساختار کلی این الگوی طراحی را مشاهده می کنید. 

![image](https://github.com/smmhatami/SE-Lab4/assets/62210297/3c7fe7dc-f3b3-42f9-a3eb-3ec1b27b6758)

الگوی Strategy: روش ارسال یک بسته فقط در متد محاسبه ی قیمت آن اثر دارد که الگوی طراحی Strategy مناسب با این نیازمندی می باشد. در ساختار کلی این الگو نیز یک Context داریم که یک عملکرد مشخص را به چند روش انجام می دهد. هر کدام از این روش ها در قالب یک Stragegy که در این موجودیت ذخیره می شوند تعریف و پیاده سازی می شوند. در مسئله ی ما یک ارسال بسته یا Shipping معادل با Context ما است که روش های مختلف ارسال هر کدام یک استراتژی برای محاسبه ی قیمت آن هستند. در تصویر زیر ساختار کلی این الگوی طراحی را مشاهده می کنید. 

![image](https://github.com/smmhatami/SE-Lab4/assets/62210297/fef528b6-5977-4e15-b950-c989f81a9434)



طراحی انجام شده در این لینک قابل دسترسی است. 
[فایل طراحی ](https://drive.google.com/file/d/1pAejYNyRA5LEjMhMNyBHfvyqO78001jy/view?usp=sharing)

### گام دو : توسعه ی تست ها 
حال با توجه به طراحی انجام شده تست های واحد مناسب با این طراحی را پیاده سازی می کنیم تا روش پیاده سازی ما آزمون رانه باشد. مانند آزمایش قبل وقتی که تست ها را اجرا کنیم به خطا بر میخوریم تا زمانی که پیاده سازی اصل برنامه را شروع کنیم. 

![Screenshot from 2023-11-22 18-57-17](https://github.com/smmhatami/SE-Lab4/assets/62210297/54319a3f-f7a1-41e1-b462-3b1f3dd6755d)

### گام سه : پیاده سازی بنده پروژه
در این گام ابتدا به رفع ارور های کامپایلی می پردازیم، سپس تست ها را تک به تک اجرا کرده و اقدام به پیاده سازی کلاس ها به صورتی کرده که تست ها پاس بشوند. در تصویر زیر نمایی از پروژه در حالتی که تست ها در ابتدا همگی fail شده اند را مشاهده می کنید:
![Screenshot 2023-11-22 214921](https://github.com/smmhatami/SE-Lab4/assets/61017890/949fe4c1-7bb0-4c46-b5dd-5a83c1fb40d9)

پس از پیاده سازی کلاس ها تست ها را اجرا کرده و تمامی آنها پاس میشوند:

![Screenshot 2023-11-22 223035](https://github.com/smmhatami/SE-Lab4/assets/61017890/8e66ed24-7ae1-4f1f-bdfd-e1a46aa54d40)

![Screenshot 2023-11-22 223017](https://github.com/smmhatami/SE-Lab4/assets/61017890/82721d71-59c5-4c57-922b-20dca492121d)

حال برای اجرای پروژه نیازمند یک view ساده هستیم، این کار را درون کلاس Main انجام می دهیم:


![Screenshot 2023-11-22 225659](https://github.com/smmhatami/SE-Lab4/assets/61017890/d72abe4e-0fac-4604-863c-26ceb84c9642)

## پرسش ها 
1. سه دسته ی کلی بیان شده در کتاب GoF عبارتند از : الگوی های Creational، Behavioral و Structural
   * الگو های Creational : این الگو ها بر نحوه ی ساخته شدن نمونه های مختلف از یک کلاس متمرکز هستند. در سامانه هایی که موجودیت های مختلف ارتباط های گوناگونی با هم دارند و نوع های ساخته شدن آن ها نیز به هم وابسته است، این ساختار ها تلاش می کنند تا تحقق اصول SOLID را در کد ما آسان تر سازند و انتشار تغییرات در هر یک از این موجودیت ها را به حداقل برسانند. برای مثال ممکن است ما در ساخت یک خانه که مدرن یا قدیمی باشد، تمام المان های آن شامل در، پنجره، لوستر و ... را به یک شکل مدرن یا قدیمی طراحی کنیم و این هماهنگی نیاز به یک الگوی طراحی متناسب با خود دارد.
  
   * الگوهای Behavioral : این الگوها به نحوه ی تعامل زمان اجرای موجودیت های مختلف توجه نشان می دهند. یکسری از رفتار های موجودیت های مختلف ساختار های پر تکراری در بین سامانه های مختلف دارند که در این ساختار ها اختصاص وظیفه ها و شیوه ی پیاده شدن الگوریتم های مختلف در بین موجودیت ها مشخص شده است. دو الگوی پیاده سازی شده در این آزمایش نمونه هایی از این دسته هستند که یکی از آن ها تقسیمی برای وظیفه ی نگهداری وضعیت انجام داده بود و دیگری وظیفه ی انجام دادن یکسری محاسبات را با توجه به تنوع آن از موجودیت اصلی ما جدا کرده بود.
   * الگوهای Structural : این الگو ها به ساختار طراحی موجودیت های پیچیده و نحوه ی کنار هم قرار گیری موجودیت های مختلف اهتمام می ورزند. هنگامی که یک موجودیت بزرگ و پیچیده از زیربخش های متعددی تشکیل شده است یا میخواهیم یک موجودیت را به طرز محافظت شده در اختیار موجودیت دیگری قرار دهیم، از نمونه هایی از این الگو ها استفاده می کنیم. از موضوعات مورد توجه در این الگوها این است که علیرغم پیچیده شدن ساختار های بزرگ، بهینگی و انعطاف پذیری آن ها در اجرا و تغییر از دست نرود و بتوان اجزای آن ها را به راحتی تعویض یا ... کرد.
2. هر دوی الگوهای State و Strategy جزو الگوهای Behavioral هستند که بر نحوه ی تعامل زمان اجرای موجودیت ها با یکدیگر تمرکز دارند.
3. برای تحقق این موضوع، از الگوی Singleton استفاده می کنیم. الگوی Singleton به یک کلاس اجازه می‌دهد تا دقیقاً یک نمونه (و تنها یک نمونه) از خود را ایجاد کند و از این نمونه در تمام نقاط برنامه استفاده کند. برای پیاده سازی آن ابتدا نیاز است اجازه ساخت شی از این نوع کلاس را از کلاس های دیگر بگیرم، برای اینکار کافیست constructor این کلاس را private کنیم. در مرحله بعدی یک تابع public به صورت زیر ایجاد می کنیم:
```

private Pack() {

}

public static Pack getInstance() {
    if (instance == null) {
        instance = new Pack();
    }
    return instance;
}
```
4. برای این الگوی طراحی تحقق و عدم تحقق اصول SOLID به صورت زیر خواهد بود:
+ اصل Single Responsibility Principle (SRP):

این الگو این اصل را نقض می کند زیرا به صورت همزمان دو کار را انجام میدهد: 1.تضمین می کند تنها یک شی در کل برنامه از کلاس موجود باشد 2.یک سطح دسترسی سراسری در همه جای پروژه به کلاس مربوطه ایجاد می کند
+ اصل Open/Closed Principle (OCP):
 
این الگو معمولاً بدون تغییر در کد موجود قابلیت افزودن ویژگی‌های جدید به کلاس را فراهم می‌کند.
+ اصل Liskov Substitution Principle (LSP):

الگوی Singleton بدون مشکل در تعامل با کد‌هایی که از نمونه‌های Singleton استفاده می‌کنند، قابل استفاده است.

+ اصل Interface Segregation Principle (ISP):

این اصل به طور مستقیم با الگوی Singleton ارتباطی ندارد، زیرا الگوی Singleton معمولاً بر اساس یک کلاس است و وابستگی به واسطه‌ها ندارد و این اصل را نقض نمی کند.
+ اصل Dependency Inversion Principle (DIP):

الگوی Singleton نمونه کلاس را ایجاد می‌کند و از آن استفاده می‌کند، اما به طور مستقیم به وابستگی‌ها و معکوس‌شدگی وابستگی‌ها توجه نمی‌کند.

 
